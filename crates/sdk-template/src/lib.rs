//! Khafi SDK Template
//!
//! This is the base SDK template that gets customized for each customer use case.
//! The Logic Compiler generates a custom version of this SDK with:
//! 1. The compiled guest program (with custom business logic)
//! 2. Type-safe input builders for the specific use case
//! 3. Helper functions for the customer's domain

pub mod prover;
pub mod zcash_client;
pub mod builders;

use khafi_common::{GuestInputs, Receipt, Result, ZcashInputs, BusinessInputs, Nullifier};
use anyhow::Context;
use methods::{GUEST_ELF, GUEST_ID};

/// Convert RISC Zero Image ID format ([u32; 8]) to our format ([u8; 32])
fn image_id_to_bytes(id: &[u32; 8]) -> [u8; 32] {
    let mut bytes = [0u8; 32];
    for (i, &word) in id.iter().enumerate() {
        let word_bytes = word.to_le_bytes();
        bytes[i * 4..(i + 1) * 4].copy_from_slice(&word_bytes);
    }
    bytes
}

/// Main SDK struct - customers interact with this
pub struct KhafiSDK {
    /// The Image ID of the compiled guest program
    /// This is unique per customer/use-case
    image_id: [u8; 32],

    /// URL of the Zcash backend service (for fetching commitment tree root)
    zcash_backend_url: String,

    /// Gateway URL (for submitting proofs)
    gateway_url: String,
}

impl KhafiSDK {
    /// Create a new SDK instance with the default embedded guest program
    ///
    /// # Arguments
    /// * `zcash_backend_url` - URL of the Zcash backend service (e.g., "http://localhost:8081")
    /// * `gateway_url` - URL of the Khafi gateway (e.g., "http://localhost:8080")
    pub fn new(zcash_backend_url: String, gateway_url: String) -> Self {
        let image_id = image_id_to_bytes(&GUEST_ID);
        Self {
            image_id,
            zcash_backend_url,
            gateway_url,
        }
    }

    /// Create a new SDK instance with a custom Image ID
    ///
    /// This is useful for testing or when using a custom guest program.
    ///
    /// # Arguments
    /// * `image_id` - The unique Image ID for the guest program
    /// * `zcash_backend_url` - URL of the Zcash backend service
    /// * `gateway_url` - URL of the Khafi gateway
    pub fn with_custom_image_id(
        image_id: [u8; 32],
        zcash_backend_url: String,
        gateway_url: String,
    ) -> Self {
        Self {
            image_id,
            zcash_backend_url,
            gateway_url,
        }
    }

    /// Get the Image ID being used by this SDK
    pub fn image_id(&self) -> [u8; 32] {
        self.image_id
    }

    /// Generate a zero-knowledge proof for business logic validation
    ///
    /// This is the main function customers call to create proofs.
    ///
    /// # Arguments
    /// * `nullifier` - Nullifier from user's Zcash payment transaction
    /// * `zcash_inputs` - DEPRECATED: Zcash payment data (kept for backward compatibility)
    /// * `business_inputs` - Customer-specific private data and validation parameters
    ///
    /// # Returns
    /// A `Receipt` containing the zk-STARK proof and the Image ID
    pub async fn generate_proof(
        &self,
        nullifier: Nullifier,
        zcash_inputs: ZcashInputs,
        business_inputs: BusinessInputs,
    ) -> Result<Receipt> {
        // Combine inputs
        let guest_inputs = GuestInputs {
            zcash: zcash_inputs,
            nullifier,
            business: business_inputs,
        };

        // Generate proof using RISC Zero
        self.prove(guest_inputs).await
    }

    /// Submit a proof to the gateway and call the protected API
    ///
    /// # Arguments
    /// * `receipt` - The proof generated by `generate_proof`
    /// * `nullifier` - The nullifier extracted from the proof
    /// * `api_endpoint` - The protected API endpoint to call
    ///
    /// # Returns
    /// The API response if the proof is valid
    pub async fn call_api(
        &self,
        receipt: &Receipt,
        nullifier: &khafi_common::Nullifier,
        api_endpoint: &str,
    ) -> Result<reqwest::Response> {
        let client = reqwest::Client::new();

        // Serialize receipt and nullifier
        let receipt_bytes = bincode::serde::encode_to_vec(receipt, bincode::config::standard())?;
        let receipt_b64 = base64::encode(&receipt_bytes);
        let nullifier_hex = nullifier.to_hex();

        // Make request with proof headers
        let response = client
            .get(format!("{}/{}", self.gateway_url, api_endpoint))
            .header("x-zk-receipt", receipt_b64)
            .header("x-zk-nullifier", nullifier_hex)
            .send()
            .await
            .context("Failed to call gateway API")?;

        Ok(response)
    }

    /// Internal: Generate proof using RISC Zero
    async fn prove(&self, inputs: GuestInputs) -> Result<Receipt> {
        // Generate the proof using the embedded guest program
        crate::prover::generate_proof(inputs, GUEST_ELF, self.image_id)
    }
}

/// Base64 encoding (add to dependencies if needed)
mod base64 {
    pub fn encode(data: &[u8]) -> String {
        // TODO: Use actual base64 crate
        hex::encode(data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sdk_creation() {
        let sdk = KhafiSDK::new(
            "http://localhost:8081".to_string(),
            "http://localhost:8080".to_string(),
        );
        // Check that the Image ID was set from the embedded GUEST_ID
        assert_eq!(sdk.image_id(), image_id_to_bytes(&GUEST_ID));
    }

    #[test]
    fn test_sdk_custom_image_id() {
        let custom_id = [42u8; 32];
        let sdk = KhafiSDK::with_custom_image_id(
            custom_id,
            "http://localhost:8081".to_string(),
            "http://localhost:8080".to_string(),
        );
        assert_eq!(sdk.image_id(), custom_id);
    }
}

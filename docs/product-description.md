This files documents **Khafi-Gateway**, providing the complete technical architecture and implementation plan using **Envoy Proxy** and the latest **Zcash** and **RISC Zero** standards.

**Khafi** ($\text{ÿÆŸéŸÅŸêŸäŸë}$) means **Hidden** or **Secret** in Arabic, perfectly encapsulating the core value proposition: providing **verifiable access** to sensitive APIs based on hidden, zero-knowledge proofs.

-----

## üìÑ Khafi-Gateway: Technical Documentation

### Executive Summary: Verifiable Private Access (VPA)

The **Khafi-Gateway** is an architectural solution that places a Zero-Knowledge Proof (ZKP) verification layer in the critical path of API requests. It leverages the **Envoy External Authorization (ExtAuth) filter** to delegate access control to a high-performance **RISC Zero Verification Service**. This service verifies a zk-STARK proof generated by the client, which confirms a shielded Zcash payment and arbitrary private business logic were executed correctly, all without revealing the private inputs.

The result is **Verifiable Private Access (VPA)**, ideal for regulatory and sensitive APIs (e.g., private financial data, health records, compliant shipping manifests).

-----

## 1\. Product Architecture & Component Flow

The Khafi-Gateway is structured as a three-tier microservice architecture to decouple high-speed routing from cryptographic computation and slow blockchain state management.

### 1.1 The Client (Prover)

  * **Technology:** User-facing application using a **Generated Khafi Client SDK** (customized per business via Logic Compiler).
  * **Inputs (Dual Verification):**
    * **Universal (Zcash Payment):**
      - Private: Zcash Spending Key, Note, Merkle Path
      - Public: Zcash Merkle Root (from Backend Abstraction)
    * **Custom (Business Logic):**
      - Private: Business-specific data (e.g., encrypted prescription, shipping manifest, patient records, KYC documents)
      - Public: Validation parameters (e.g., age thresholds, compliance rules, blacklists)
  * **Process:** Runs the compiled **RISC Zero Guest Code** containing:
    1. **Standard Zcash verification** (proves payment was made)
    2. **Custom business logic** (proves compliance with domain-specific rules)
  * **Output:** Generates the **RISC Zero Receipt** (zk-STARK proof) with:
    - Payment Nullifier (anti-replay for Zcash note)
    - Compliance Result (boolean: did business validation pass?)
    - Optional Metadata (proof of what was verified, without revealing private data)

### 1.2 The Gateway Router (Envoy Proxy)

  * **Technology:** **Envoy Proxy** configured as an HTTP Filter Chain.
  * **Role:** Extracts the proof data from the request headers/body and delegates authorization.
  * **Mechanism:** Uses the `envoy.filters.http.ext_authz` filter to send a gRPC `CheckRequest` to the ZK Verification Service, passing the proof and Nullifiers.
  * **Authorization:** Only proceeds to the Upstream API if the ZK Verification Service returns a gRPC success message (equivalent to HTTP 200 OK).

### 1.3 The ZK Verification Service (Rust Microservice)

  * **Technology:** High-performance **Rust** microservice with **RISC Zero Verifier** crates. Implements the `envoy.service.auth.v3.Authorization` gRPC service.
  * **Role:** The cryptographic choke point. Verifies the proof and checks for replay attacks.
  * **Process:**
    1.  Receives `CheckRequest` from Envoy.
    2.  Calls `risc0_zkvm::Verifier::verify()` against the registered **Image ID** (the hash of the expected Guest Code).
    3.  Reads the Journal to extract $\text{Nullifier}_{\text{Payment}}$ and the compliance $\text{Result}$.
    4.  Pings the Zcash Backend Abstraction to validate the $\text{Nullifier}_{\text{Payment}}$.
    5.  **Decision:** Returns gRPC Success/Failure based on the verification result.

-----

## 2\. Zcash Infrastructure Abstraction Details üîë

The **Khafi-Gateway** achieves its Zcash integration through a dedicated, isolated service, preventing the core verification engine from being bogged down by blockchain synchronization. The latest Zcash shielded protocol, **Orchard** (using the Halo 2 proving system), is assumed.

### 2.1 The Zcash Backend Abstraction Service

This service provides a highly available, read-only interface to the Zcash shielded state.

| Data/Function | Implementation Details | Use Case in ZKPG |
| :--- | :--- | :--- |
| **Commitment Tree Root** | Running a **Zcash Light Client** (e.g., based on *zebra* or *zcashd* in light mode) or a dedicated API service exposing the latest **Orchard Merkle Tree Root**. | **Crucial Prover Input:** The Prover uses this public root to prove their shielded Note's inclusion in the chain. This root is fetched by the Client SDK before proof generation. |
| **Nullifier Database (State)** | **High-availability Key-Value Store** (e.g., Redis or a dedicated PostgreSQL table). Stores the set of *consumed* shielded $\text{Nullifier}_{\text{Payment}}$ values. | **Anti-Replay Check:** The ZK Verification Service atomically checks and sets the Nullifier to ensure the Zcash Note is used for access only once. |
| **Zcash Cryptography Crates** | Rust crates like `zcash_primitives` and `orchard` compiled to standard target (for the Verification Service) and to the $\text{risc0-zkvm}$ target (for the Guest Code). | Provides functions like $\text{Note}$ decryption, $\text{Nullifier}$ derivation, and $\text{Commitment}$ calculation within the verifiable environment. |

### 2.2 Nullifier Management Protocol (Anti-Replay)

1.  **Generation:** The Client's RISC Zero Guest Code computes a unique **Nullifier** for the Zcash shielded payment (Note) using the Note's position and the user's key‚Äîa process essential to Zcash spending.
2.  **Transmission:** The Client sends the Nullifier publicly in the `X-ZK-Nullifier` header alongside the Receipt.
3.  **Verification:** The ZK Verification Service receives the Nullifier and executes the atomic check:
      * **IF** `Nullifier` exists in the Nullifier Database $\implies$ **REJECT (401 Forbidden)**.
      * **ELSE** **Insert** `Nullifier` into the database and proceed $\implies$ **ACCEPT (200 OK)**.

-----

## 3\. Deployment and Configuration (Khafi-Gateway)

### 3.1 Envoy Configuration Snippet (Illustrative)

The Envoy configuration must be set to extract the large ZK proof data and forward it to the external gRPC service.

```yaml
static_resources:
  listeners:
  - name: listener_0
    address: { socket_address: { address: 0.0.0.0, port_value: 8080 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          # ... other configs ...
          http_filters:
          - name: envoy.filters.http.ext_authz # <- The ZK check filter
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
              grpc_service:
                envoy_grpc:
                  cluster_name: zk_verification_service_cluster
                timeout: 0.5s # Should be kept low
              # Map specific headers/body containing the proof to the CheckRequest
              check_request_config:
                allowed_headers:
                  patterns:
                    - exact: "x-zk-receipt"
                    - exact: "x-zk-nullifier"
          - name: envoy.filters.http.router
  clusters:
  - name: zk_verification_service_cluster
    type: STRICT_DNS
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: zk_verification_service_cluster
      endpoints:
      - lb_endpoints:
        - endpoint:
            address: { socket_address: { address: "zk-verification-service", port_value: 50051 } }
```

### 3.2 Logic Compiler Service (Core Component)

The **Logic Compiler Service** is the KEY DIFFERENTIATOR that makes Khafi-Gateway a SaaS platform rather than just infrastructure. It transforms business rules into custom, cryptographically-verified SDKs without requiring customers to write Rust or understand zero-knowledge proofs.

#### Architecture:

**Logic Compiler Service** (Rust microservice):
1.  **Input:** User-defined validation rules via REST API/Web UI (JSON DSL format)
    - Example (Pharma): `{"type": "prescription_validation", "rules": [{"check": "prescriber_signature"}, {"check": "quantity_limit", "max": 30}]}`
    - Example (Shipping): `{"type": "manifest_compliance", "rules": [{"check": "not_sanctioned", "field": "destination"}, {"check": "prohibited_items", "blacklist": ["weapons"]}]}`

2.  **Code Generation:**
    - Parses JSON DSL into an Abstract Syntax Tree (AST)
    - Generates Rust guest program code combining:
      * **Standard template:** Zcash payment verification (fixed for all customers)
      * **Custom logic:** Business-specific validation rules (unique per customer)
    - Injects type-safe input/output serialization code

3.  **Compilation:**
    - Compiles generated Rust code to RISC Zero `rv32im` target
    - Produces verifiable binary with deterministic **Image ID** (cryptographic hash)

4.  **SDK Packaging:**
    - Bundles compiled guest program into a complete SDK crate
    - Includes: proof generation API, input builders, helper functions
    - Exposes simple interface: `sdk.generate_proof(payment_data, business_data)`

5.  **Registration & Deployment:**
    - Registers the **Image ID** with the ZK Verification Service (allows proof verification)
    - Stores SDK metadata (customer ID, version, capabilities) in SDK Registry
    - Returns downloadable SDK package to customer

#### Customer Workflow:

```
Customer defines rules in JSON ‚Üí Logic Compiler generates SDK ‚Üí Customer integrates SDK ‚Üí Client generates proofs ‚Üí Gateway verifies proofs
```

#### Example DSL Formats:

**Pharma (Prescription Validation):**
```json
{
  "use_case": "prescription_validation",
  "private_inputs": ["prescription_json", "patient_dob"],
  "validation_rules": [
    {"type": "signature_check", "field": "prescriber_signature", "public_key_field": "prescriber_pubkey"},
    {"type": "quantity_limit", "field": "quantity", "max": 30},
    {"type": "age_check", "field": "patient_dob", "min_age": 18}
  ]
}
```

**Shipping (Manifest Compliance):**
```json
{
  "use_case": "manifest_compliance",
  "private_inputs": ["manifest_json"],
  "validation_rules": [
    {"type": "destination_check", "field": "destination_country", "blacklist": ["Country1", "Country2"]},
    {"type": "weight_limit", "field": "total_weight_kg", "max": 1000},
    {"type": "prohibited_items", "field": "contents_list", "banned_keywords": ["weapons", "explosives"]}
  ]
}
```

This architecture ensures customers never see cryptographic complexity - they define business rules, we handle ZK proofs, Zcash integration, and gateway verification.